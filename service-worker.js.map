{"version":3,"sources":["service-worker.js"],"names":["cacheName","self","scope","ignoreUrlParametersMatching","registration","addDirectoryIndex","originalUrl","index","url","URL","cleanResponse","pathname","slice","resolve","originalResponse","redirected","Response","headers","body","status","then","createCacheKey","statusText","Promise","paramName","encodeURIComponent","dontCacheBustUrlsMatching","toString","whitelist","match","search","paramValue","isPathWhitelisted","absoluteUrlString","length","stripIgnoredUrlParameters","split","some","whitelistedPathRegex","path","kv","join","map","hashParamName","relativeUrl","item","hash","every","ignoredRegex","absoluteUrl","cache","request","urlsToCacheKeys","Map","precacheConfig","addEventListener","waitUntil","caches","setOfCachedUrls","location","cacheKey","from","keys","requests","urls","Set","event","open","cachedUrls","all","Array","values","skipWaiting","has","Request","credentials","fetch","response","Error","existingRequests","responseToCache","put","setOfExpectedUrls","shouldRespond","directoryIndex","existingRequest","delete","clients","claim","console","respondWith","get","catch","e"],"mappings":"AAqCA,aAGA,IAAIA,eAAY,CAAA,CAAA,iBAAsBC,oCAAsCC,CAAAA,qBAA5E,oCAAA,CAAA,qBAAA,oCAAA,CAAA,qBAAA,oCAAA,CAAA,sBAAA,oCAAA,CAAA,uBAAA,oCAAA,CAAA,uBAAA,oCAAA,CAAA,sBAAA,oCAAA,CAAA,cAAA,oCAAA,CAAA,eAAA,oCAAA,CAAA,iBAAA,qCAGIC,UAAAA,oBAA+BF,KAAnCG,aAAAH,KAAAG,aAAAF,MAAA,IAKIC,4BAAA,CAAA,SAGCE,kBAAA,SAAAC,EAAAC,GAHD,IAAIC,EAAM,IAAIC,IAAIH,GAOlBI,MAHA,MAAAF,EAAUG,SAAHC,OAAP,KALJJ,EAAAG,UAAAJ,GAQIG,EAAAA,YAGEA,cAAeG,SAAQC,GAIzB,OAAAA,EAAAC,YAOaC,SAAeF,EACxBG,QAAOJ,QAAEC,EADeI,MAExBC,EAAQL,QAFVM,KAAA,SAAAF,GAdN,OAAA,IAAAF,SAAAE,EAAA,CAeQD,QAASH,EAAiBG,QAO9BI,OAAAA,EAAAA,OAEAC,WAAAR,EAAAQ,eArBSC,QAAQV,QAAQC,IA4BvBN,eAAeA,SAAAF,EAADkB,EACZC,EACHC,GAED,IAAAlB,EAAWmB,IAAAA,IAAJrB,GAUP,OANAoB,GACIE,EAAAA,SAAAC,MAAJH,KACElB,EAAAsB,SAAAtB,EAAAsB,OAAA,IAAA,IAGFL,mBAAAD,GAAA,IAAAC,mBAAAM,IACQvB,EAAImB,YACZK,kBAAA,SAAAJ,EAAAK,GANA,GAAyB,IAArBL,EAAUM,OAWdC,OAAAA,EAMA3B,IAAIsB,EAAStB,IAAIsB,IAAAA,GAAgBnB,SAC9ByB,OAAMR,EAAKS,KAAA,SAAAC,GADD,OAENC,EAASC,MAAIF,MAKdH,0BAA0BK,SAAQlC,EACnCH,GARQ,IAAAK,EAUN,IAAAC,IAAAH,GAuBL,OAjCWE,EAaViC,KAlB0B,GAoB7BjC,EAAAsB,OAAWH,EAAJG,OAAPlB,MAAA,GArBJwB,MAAA,KAQOM,IAAI,SAASF,GAiBhBG,OAAAA,EAAaP,MAAG,OAGZQ,OAAAA,SAAcC,GACdC,OAAOD,EAAXE,MAAA,SAAAC,GACIC,OAAWD,EAAWJ,KAAAA,EAAR,QAJtBF,IAAA,SAAAF,GATQ,OAAOA,EAAGC,KAAK,OAoBrBA,KAAOS,KAEH1C,EAAO2C,YAFXR,cAAA,eAODS,gBAAA,IAAAC,IAjBCC,eAAeZ,IAAI,SAASG,GAmB1B,IAACU,EAAiBV,EAAA,GACdW,EAAAA,EACJC,GACER,EAAOS,IAAejD,IAACyC,EAAYjD,KAAA0D,UACjCC,EAAOrC,eACCsC,EAAKT,cAA0BV,GAAI,GACvC,MAAA,CAAAO,EAAAtB,WAAAiC,MAEsC,SAAAF,gBAApCR,GACA,OAAAA,EAAAY,OAAY1C,KAAC+B,SAANY,GACL,OAAAA,EAAArB,IAAA,SAAAS,GACA,OAAAA,EAAA3C,QAEEY,KAAA,SAAA4C,GAED,OAAA,IAAAC,IAAAD,KAIA/D,KAAAsD,iBAFD,UAAA,SAAAW,GAGDA,EAAAV,UACFC,OAAAU,KAAAnE,WAAAoB,KAAA,SAAA8B,GACF,OAlBHQ,gBAAAR,GAAA9B,KAAA,SAAAgD,GADF,OAAA7C,QAAA8C,IAsBMC,MAAAT,KAAAT,gBAAWmB,UAAA7B,IAAA,SAAAkB,GAGV3D,IAAKuE,EAALC,IAAPb,GAAA,CA3BJ,IAAAT,EAAA,IAAAuB,QAAAd,EAAA,CAAAe,YAAA,gBADF,OAAAC,MAAAzB,GAAA/B,KAAA,SAAAyD,GAqCQrB,IACJC,EAAYzD,GACG8D,MAAO1C,IAAb0D,MAAkB,eAASC,EAAkB,oCAE3BF,EAAA1D,QAGlB,OAAAT,cAAAmE,GAAAzD,KAAA,SAAA4D,GAJL,OAAA9B,EAAA+B,IAAArB,EAAAoB,eAkBFd,KAAMf,WAGR,OAAAlD,KAAAuE,mBASAvE,KAAAsD,iBAAA,WAAA,SAAAW,GAnCF,IAAIgB,EAAoB,IAAIjB,IAAIb,gBAAgBmB,UAEhDL,EAAMV,UAmCJC,OAAK0B,KAAAA,WAAiBC,KAAAA,SAAtBlC,GACE1C,OAAMH,EAAAA,OAAAA,KAAkBG,SAAK4E,GAC7BD,OAAAA,QAAgB/B,IAGlB2B,EAAArC,IAAA,SAAA2C,GACA,IAAAH,EAAAT,IAAAY,EAAA7E,KAnCU,OAAO0C,EAAMoC,OAAOD,UAyC5B7E,KAAM,WAIR,OAAAP,KAAAsF,QAAAC,aAMQvF,KAAAsD,iBAAA,QAAc,SAAAW,GACZ,GAAA,QAAAA,EAAAf,QAAO0B,OAAP,CAGH,IAAAM,EAIDM,EAAAA,0BAAavB,EAAAf,QAAA3C,IAAAL,6BA7CvBiF,EAAA,cA8CUD,EAAY/B,gBAAZqB,IAAAjE,MA9BJA,EAAMH,kBAAkBG,EAAK4E,GAC7BD,EAAgB/B,gBAAgBqB,IAAIjE,IAMlC,EAUA2E,GACFjB,EAAMwB,YACJjC,OAAOU,KAAKnE,WAAWoB,KAAK,SAAS8B,GACnC,OAAOA,EAAMrB,MAAMuB,gBAAgBuC,IAAInF,IAAMY,KAAK,SAASyD,GACzD,GAAIA,EACF,OAAOA,EAET,MAAMC,MAAM,yDAEbc,MAAM,SAASC,GAIhB,OAAOjB,MAAMV,EAAMf","file":"service-worker.js","sourcesContent":["/**\n * Copyright 2016 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\n\n// DO NOT EDIT THIS GENERATED OUTPUT DIRECTLY!\n// This file should be overwritten as part of your build process.\n// If you need to extend the behavior of the generated service worker, the best approach is to write\n// additional code and include it using the importScripts option:\n//   https://github.com/GoogleChrome/sw-precache#importscripts-arraystring\n//\n// Alternatively, it's possible to make changes to the underlying template file and then use that as the\n// new base for generating output, via the templateFilePath option:\n//   https://github.com/GoogleChrome/sw-precache#templatefilepath-string\n//\n// If you go that route, make sure that whenever you update your sw-precache dependency, you reconcile any\n// changes made to this original template file with your modified copy.\n\n// This generated service worker JavaScript will precache your site's resources.\n// The code needs to be saved in a .js file at the top-level of your site, and registered\n// from your pages in order to be used. See\n// https://github.com/googlechrome/sw-precache/blob/master/demo/app/js/service-worker-registration.js\n// for an example of how you can register this script and handle various service worker events.\n\n/* eslint-env worker, serviceworker */\n/* eslint-disable indent, no-unused-vars, no-multiple-empty-lines, max-nested-callbacks, space-before-function-paren, quotes, comma-spacing */\n'use strict';\n\nvar precacheConfig = [[\"/css/index.css\",\"967d4c0512833f2cc4a7f7d4cea32d72\"],[\"/font/fontello.eot\",\"e5a945dd72ed9579b44f1926decc5d69\"],[\"/font/fontello.svg\",\"6cfcdb1a2abb96602932d4a2601d9c4e\"],[\"/font/fontello.ttf\",\"b732484010111a67bc53d44c88df79a0\"],[\"/font/fontello.woff\",\"c15f138b70af4f6b64e328b22c376c43\"],[\"/font/fontello.woff2\",\"26148360a55ef28c89c538de3c97ed5b\"],[\"/htmlminifier.min.js\",\"a665c9d18b2d13aba7468e57cc6f8c78\"],[\"/images/bg-main.png\",\"b099df35a7d9bc55229200256263759b\"],[\"/index.html\",\"339e067a8dbdfbf2dfba48fff521ad28\"],[\"/js/index.js\",\"75117e64e78f1363e0ac390a253210ec\"],[\"/web-worker.js\",\"155c5ced5d48ef4443f09206d415a92b\"]];\nvar cacheName = 'sw-precache-v3--' + (self.registration ? self.registration.scope : '');\n\n\nvar ignoreUrlParametersMatching = [/^utm_/];\n\n\n\nvar addDirectoryIndex = function(originalUrl, index) {\n    var url = new URL(originalUrl);\n    if (url.pathname.slice(-1) === '/') {\n      url.pathname += index;\n    }\n    return url.toString();\n  };\n\nvar cleanResponse = function(originalResponse) {\n    // If this is not a redirected response, then we don't have to do anything.\n    if (!originalResponse.redirected) {\n      return Promise.resolve(originalResponse);\n    }\n\n    // Firefox 50 and below doesn't support the Response.body stream, so we may\n    // need to read the entire body to memory as a Blob.\n    var bodyPromise = 'body' in originalResponse ?\n      Promise.resolve(originalResponse.body) :\n      originalResponse.blob();\n\n    return bodyPromise.then(function(body) {\n      // new Response() is happy when passed either a stream or a Blob.\n      return new Response(body, {\n        headers: originalResponse.headers,\n        status: originalResponse.status,\n        statusText: originalResponse.statusText\n      });\n    });\n  };\n\nvar createCacheKey = function(originalUrl, paramName, paramValue,\n                           dontCacheBustUrlsMatching) {\n    // Create a new URL object to avoid modifying originalUrl.\n    var url = new URL(originalUrl);\n\n    // If dontCacheBustUrlsMatching is not set, or if we don't have a match,\n    // then add in the extra cache-busting URL parameter.\n    if (!dontCacheBustUrlsMatching ||\n        !(url.pathname.match(dontCacheBustUrlsMatching))) {\n      url.search += (url.search ? '&' : '') +\n        encodeURIComponent(paramName) + '=' + encodeURIComponent(paramValue);\n    }\n\n    return url.toString();\n  };\n\nvar isPathWhitelisted = function(whitelist, absoluteUrlString) {\n    // If the whitelist is empty, then consider all URLs to be whitelisted.\n    if (whitelist.length === 0) {\n      return true;\n    }\n\n    // Otherwise compare each path regex to the path of the URL passed in.\n    var path = (new URL(absoluteUrlString)).pathname;\n    return whitelist.some(function(whitelistedPathRegex) {\n      return path.match(whitelistedPathRegex);\n    });\n  };\n\nvar stripIgnoredUrlParameters = function(originalUrl,\n    ignoreUrlParametersMatching) {\n    var url = new URL(originalUrl);\n    // Remove the hash; see https://github.com/GoogleChrome/sw-precache/issues/290\n    url.hash = '';\n\n    url.search = url.search.slice(1) // Exclude initial '?'\n      .split('&') // Split into an array of 'key=value' strings\n      .map(function(kv) {\n        return kv.split('='); // Split each 'key=value' string into a [key, value] array\n      })\n      .filter(function(kv) {\n        return ignoreUrlParametersMatching.every(function(ignoredRegex) {\n          return !ignoredRegex.test(kv[0]); // Return true iff the key doesn't match any of the regexes.\n        });\n      })\n      .map(function(kv) {\n        return kv.join('='); // Join each [key, value] array into a 'key=value' string\n      })\n      .join('&'); // Join the array of 'key=value' strings into a string with '&' in between each\n\n    return url.toString();\n  };\n\n\nvar hashParamName = '_sw-precache';\nvar urlsToCacheKeys = new Map(\n  precacheConfig.map(function(item) {\n    var relativeUrl = item[0];\n    var hash = item[1];\n    var absoluteUrl = new URL(relativeUrl, self.location);\n    var cacheKey = createCacheKey(absoluteUrl, hashParamName, hash, false);\n    return [absoluteUrl.toString(), cacheKey];\n  })\n);\n\nfunction setOfCachedUrls(cache) {\n  return cache.keys().then(function(requests) {\n    return requests.map(function(request) {\n      return request.url;\n    });\n  }).then(function(urls) {\n    return new Set(urls);\n  });\n}\n\nself.addEventListener('install', function(event) {\n  event.waitUntil(\n    caches.open(cacheName).then(function(cache) {\n      return setOfCachedUrls(cache).then(function(cachedUrls) {\n        return Promise.all(\n          Array.from(urlsToCacheKeys.values()).map(function(cacheKey) {\n            // If we don't have a key matching url in the cache already, add it.\n            if (!cachedUrls.has(cacheKey)) {\n              var request = new Request(cacheKey, {credentials: 'same-origin'});\n              return fetch(request).then(function(response) {\n                // Bail out of installation unless we get back a 200 OK for\n                // every request.\n                if (!response.ok) {\n                  throw new Error('Request for ' + cacheKey + ' returned a ' +\n                    'response with status ' + response.status);\n                }\n\n                return cleanResponse(response).then(function(responseToCache) {\n                  return cache.put(cacheKey, responseToCache);\n                });\n              });\n            }\n          })\n        );\n      });\n    }).then(function() {\n      \n      // Force the SW to transition from installing -> active state\n      return self.skipWaiting();\n      \n    })\n  );\n});\n\nself.addEventListener('activate', function(event) {\n  var setOfExpectedUrls = new Set(urlsToCacheKeys.values());\n\n  event.waitUntil(\n    caches.open(cacheName).then(function(cache) {\n      return cache.keys().then(function(existingRequests) {\n        return Promise.all(\n          existingRequests.map(function(existingRequest) {\n            if (!setOfExpectedUrls.has(existingRequest.url)) {\n              return cache.delete(existingRequest);\n            }\n          })\n        );\n      });\n    }).then(function() {\n      \n      return self.clients.claim();\n      \n    })\n  );\n});\n\n\nself.addEventListener('fetch', function(event) {\n  if (event.request.method === 'GET') {\n    // Should we call event.respondWith() inside this fetch event handler?\n    // This needs to be determined synchronously, which will give other fetch\n    // handlers a chance to handle the request if need be.\n    var shouldRespond;\n\n    // First, remove all the ignored parameters and hash fragment, and see if we\n    // have that URL in our cache. If so, great! shouldRespond will be true.\n    var url = stripIgnoredUrlParameters(event.request.url, ignoreUrlParametersMatching);\n    shouldRespond = urlsToCacheKeys.has(url);\n\n    // If shouldRespond is false, check again, this time with 'index.html'\n    // (or whatever the directoryIndex option is set to) at the end.\n    var directoryIndex = 'index.html';\n    if (!shouldRespond && directoryIndex) {\n      url = addDirectoryIndex(url, directoryIndex);\n      shouldRespond = urlsToCacheKeys.has(url);\n    }\n\n    // If shouldRespond is still false, check to see if this is a navigation\n    // request, and if so, whether the URL matches navigateFallbackWhitelist.\n    var navigateFallback = '';\n    if (!shouldRespond &&\n        navigateFallback &&\n        (event.request.mode === 'navigate') &&\n        isPathWhitelisted([], event.request.url)) {\n      url = new URL(navigateFallback, self.location).toString();\n      shouldRespond = urlsToCacheKeys.has(url);\n    }\n\n    // If shouldRespond was set to true at any point, then call\n    // event.respondWith(), using the appropriate cache key.\n    if (shouldRespond) {\n      event.respondWith(\n        caches.open(cacheName).then(function(cache) {\n          return cache.match(urlsToCacheKeys.get(url)).then(function(response) {\n            if (response) {\n              return response;\n            }\n            throw Error('The cached response that was expected is missing.');\n          });\n        }).catch(function(e) {\n          // Fall back to just fetch()ing the request if some unexpected error\n          // prevented the cached response from being valid.\n          console.warn('Couldn\\'t serve response for \"%s\" from cache: %O', event.request.url, e);\n          return fetch(event.request);\n        })\n      );\n    }\n  }\n});\n\n\n\n\n\n\n\n"]}