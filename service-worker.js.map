{"version":3,"sources":["service-worker.js"],"names":["setOfCachedUrls","has","cache","request","cacheKey","requests","fetch","then","url","response","Set","urls","precacheConfig","cacheName","self","registration","scope","ignoreUrlParametersMatching","index","originalUrl","URL","cleanResponse","slice","pathname","resolve","originalResponse","redirected","Promise","Response","body","headers","statusText","status","createCacheKey","paramName","paramValue","dontCacheBustUrlsMatching","isPathWhitelisted","search","whitelist","encodeURIComponent","toString","whitelistedPathRegex","length","path","absoluteUrlString","some","match","stripIgnoredUrlParameters","hash","join","map","kv","filter","hashParamName","every","ignoredRegex","urlsToCacheKeys","absoluteUrl","Map","item","relativeUrl","location","addEventListener","event","waitUntil","caches","responseToCache","open","cachedUrls","all","Array","from","values","Request","credentials","skipWaiting","ok","Error","existingRequests","setOfExpectedUrls","shouldRespond","existingRequest","delete","clients","claim","method","addDirectoryIndex","respondWith","get","catch","e"],"mappings":"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","file":"service-worker.js","sourcesContent":["/**\n * Copyright 2016 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\n\n// DO NOT EDIT THIS GENERATED OUTPUT DIRECTLY!\n// This file should be overwritten as part of your build process.\n// If you need to extend the behavior of the generated service worker, the best approach is to write\n// additional code and include it using the importScripts option:\n//   https://github.com/GoogleChrome/sw-precache#importscripts-arraystring\n//\n// Alternatively, it's possible to make changes to the underlying template file and then use that as the\n// new base for generating output, via the templateFilePath option:\n//   https://github.com/GoogleChrome/sw-precache#templatefilepath-string\n//\n// If you go that route, make sure that whenever you update your sw-precache dependency, you reconcile any\n// changes made to this original template file with your modified copy.\n\n// This generated service worker JavaScript will precache your site's resources.\n// The code needs to be saved in a .js file at the top-level of your site, and registered\n// from your pages in order to be used. See\n// https://github.com/googlechrome/sw-precache/blob/master/demo/app/js/service-worker-registration.js\n// for an example of how you can register this script and handle various service worker events.\n\n/* eslint-env worker, serviceworker */\n/* eslint-disable indent, no-unused-vars, no-multiple-empty-lines, max-nested-callbacks, space-before-function-paren, quotes, comma-spacing */\n'use strict';\n\nvar precacheConfig = [[\"/css/index.css\",\"194e16dbcf798641af78097b3a97c45d\"],[\"/font/fontello.eot\",\"e5a945dd72ed9579b44f1926decc5d69\"],[\"/font/fontello.svg\",\"6cfcdb1a2abb96602932d4a2601d9c4e\"],[\"/font/fontello.ttf\",\"b732484010111a67bc53d44c88df79a0\"],[\"/font/fontello.woff\",\"c15f138b70af4f6b64e328b22c376c43\"],[\"/font/fontello.woff2\",\"26148360a55ef28c89c538de3c97ed5b\"],[\"/htmlminifier.min.js\",\"0cd9f4e274ea89f690b28790076658fa\"],[\"/images/bg-main.png\",\"b099df35a7d9bc55229200256263759b\"],[\"/index.html\",\"11092e978da2c4f9839db29889f014e4\"],[\"/js/index.js\",\"377212b5ca7d1cdd1df1ee49e6a65f2c\"],[\"/web-worker.js\",\"c1c9603d2795ca83f8f49178cb0e25b5\"]];\nvar cacheName = 'sw-precache-v3--' + (self.registration ? self.registration.scope : '');\n\n\nvar ignoreUrlParametersMatching = [/^utm_/];\n\n\n\nvar addDirectoryIndex = function (originalUrl, index) {\n    var url = new URL(originalUrl);\n    if (url.pathname.slice(-1) === '/') {\n      url.pathname += index;\n    }\n    return url.toString();\n  };\n\nvar cleanResponse = function (originalResponse) {\n    // If this is not a redirected response, then we don't have to do anything.\n    if (!originalResponse.redirected) {\n      return Promise.resolve(originalResponse);\n    }\n\n    // Firefox 50 and below doesn't support the Response.body stream, so we may\n    // need to read the entire body to memory as a Blob.\n    var bodyPromise = 'body' in originalResponse ?\n      Promise.resolve(originalResponse.body) :\n      originalResponse.blob();\n\n    return bodyPromise.then(function(body) {\n      // new Response() is happy when passed either a stream or a Blob.\n      return new Response(body, {\n        headers: originalResponse.headers,\n        status: originalResponse.status,\n        statusText: originalResponse.statusText\n      });\n    });\n  };\n\nvar createCacheKey = function (originalUrl, paramName, paramValue,\n                           dontCacheBustUrlsMatching) {\n    // Create a new URL object to avoid modifying originalUrl.\n    var url = new URL(originalUrl);\n\n    // If dontCacheBustUrlsMatching is not set, or if we don't have a match,\n    // then add in the extra cache-busting URL parameter.\n    if (!dontCacheBustUrlsMatching ||\n        !(url.pathname.match(dontCacheBustUrlsMatching))) {\n      url.search += (url.search ? '&' : '') +\n        encodeURIComponent(paramName) + '=' + encodeURIComponent(paramValue);\n    }\n\n    return url.toString();\n  };\n\nvar isPathWhitelisted = function (whitelist, absoluteUrlString) {\n    // If the whitelist is empty, then consider all URLs to be whitelisted.\n    if (whitelist.length === 0) {\n      return true;\n    }\n\n    // Otherwise compare each path regex to the path of the URL passed in.\n    var path = (new URL(absoluteUrlString)).pathname;\n    return whitelist.some(function(whitelistedPathRegex) {\n      return path.match(whitelistedPathRegex);\n    });\n  };\n\nvar stripIgnoredUrlParameters = function (originalUrl,\n    ignoreUrlParametersMatching) {\n    var url = new URL(originalUrl);\n    // Remove the hash; see https://github.com/GoogleChrome/sw-precache/issues/290\n    url.hash = '';\n\n    url.search = url.search.slice(1) // Exclude initial '?'\n      .split('&') // Split into an array of 'key=value' strings\n      .map(function(kv) {\n        return kv.split('='); // Split each 'key=value' string into a [key, value] array\n      })\n      .filter(function(kv) {\n        return ignoreUrlParametersMatching.every(function(ignoredRegex) {\n          return !ignoredRegex.test(kv[0]); // Return true iff the key doesn't match any of the regexes.\n        });\n      })\n      .map(function(kv) {\n        return kv.join('='); // Join each [key, value] array into a 'key=value' string\n      })\n      .join('&'); // Join the array of 'key=value' strings into a string with '&' in between each\n\n    return url.toString();\n  };\n\n\nvar hashParamName = '_sw-precache';\nvar urlsToCacheKeys = new Map(\n  precacheConfig.map(function(item) {\n    var relativeUrl = item[0];\n    var hash = item[1];\n    var absoluteUrl = new URL(relativeUrl, self.location);\n    var cacheKey = createCacheKey(absoluteUrl, hashParamName, hash, false);\n    return [absoluteUrl.toString(), cacheKey];\n  })\n);\n\nfunction setOfCachedUrls(cache) {\n  return cache.keys().then(function(requests) {\n    return requests.map(function(request) {\n      return request.url;\n    });\n  }).then(function(urls) {\n    return new Set(urls);\n  });\n}\n\nself.addEventListener('install', function(event) {\n  event.waitUntil(\n    caches.open(cacheName).then(function(cache) {\n      return setOfCachedUrls(cache).then(function(cachedUrls) {\n        return Promise.all(\n          Array.from(urlsToCacheKeys.values()).map(function(cacheKey) {\n            // If we don't have a key matching url in the cache already, add it.\n            if (!cachedUrls.has(cacheKey)) {\n              var request = new Request(cacheKey, {credentials: 'same-origin'});\n              return fetch(request).then(function(response) {\n                // Bail out of installation unless we get back a 200 OK for\n                // every request.\n                if (!response.ok) {\n                  throw new Error('Request for ' + cacheKey + ' returned a ' +\n                    'response with status ' + response.status);\n                }\n\n                return cleanResponse(response).then(function(responseToCache) {\n                  return cache.put(cacheKey, responseToCache);\n                });\n              });\n            }\n          })\n        );\n      });\n    }).then(function() {\n      \n      // Force the SW to transition from installing -> active state\n      return self.skipWaiting();\n      \n    })\n  );\n});\n\nself.addEventListener('activate', function(event) {\n  var setOfExpectedUrls = new Set(urlsToCacheKeys.values());\n\n  event.waitUntil(\n    caches.open(cacheName).then(function(cache) {\n      return cache.keys().then(function(existingRequests) {\n        return Promise.all(\n          existingRequests.map(function(existingRequest) {\n            if (!setOfExpectedUrls.has(existingRequest.url)) {\n              return cache.delete(existingRequest);\n            }\n          })\n        );\n      });\n    }).then(function() {\n      \n      return self.clients.claim();\n      \n    })\n  );\n});\n\n\nself.addEventListener('fetch', function(event) {\n  if (event.request.method === 'GET') {\n    // Should we call event.respondWith() inside this fetch event handler?\n    // This needs to be determined synchronously, which will give other fetch\n    // handlers a chance to handle the request if need be.\n    var shouldRespond;\n\n    // First, remove all the ignored parameters and hash fragment, and see if we\n    // have that URL in our cache. If so, great! shouldRespond will be true.\n    var url = stripIgnoredUrlParameters(event.request.url, ignoreUrlParametersMatching);\n    shouldRespond = urlsToCacheKeys.has(url);\n\n    // If shouldRespond is false, check again, this time with 'index.html'\n    // (or whatever the directoryIndex option is set to) at the end.\n    var directoryIndex = 'index.html';\n    if (!shouldRespond && directoryIndex) {\n      url = addDirectoryIndex(url, directoryIndex);\n      shouldRespond = urlsToCacheKeys.has(url);\n    }\n\n    // If shouldRespond is still false, check to see if this is a navigation\n    // request, and if so, whether the URL matches navigateFallbackWhitelist.\n    var navigateFallback = '';\n    if (!shouldRespond &&\n        navigateFallback &&\n        (event.request.mode === 'navigate') &&\n        isPathWhitelisted([], event.request.url)) {\n      url = new URL(navigateFallback, self.location).toString();\n      shouldRespond = urlsToCacheKeys.has(url);\n    }\n\n    // If shouldRespond was set to true at any point, then call\n    // event.respondWith(), using the appropriate cache key.\n    if (shouldRespond) {\n      event.respondWith(\n        caches.open(cacheName).then(function(cache) {\n          return cache.match(urlsToCacheKeys.get(url)).then(function(response) {\n            if (response) {\n              return response;\n            }\n            throw Error('The cached response that was expected is missing.');\n          });\n        }).catch(function(e) {\n          // Fall back to just fetch()ing the request if some unexpected error\n          // prevented the cached response from being valid.\n          console.warn('Couldn\\'t serve response for \"%s\" from cache: %O', event.request.url, e);\n          return fetch(event.request);\n        })\n      );\n    }\n  }\n});\n\n\n\n\n\n\n\n"]}