{"version":3,"sources":["service-worker.js"],"names":["precacheConfig","cacheName","self","registration","scope","ignoreUrlParametersMatching","url","index","originalUrl","URL","cleanResponse","slice","pathname","resolve","originalResponse","redirected","Promise","Response","body","headers","statusText","status","createCacheKey","paramName","paramValue","dontCacheBustUrlsMatching","isPathWhitelisted","search","whitelist","encodeURIComponent","toString","whitelistedPathRegex","length","path","absoluteUrlString","some","match","stripIgnoredUrlParameters","hash","join","map","kv","filter","hashParamName","every","ignoredRegex","urlsToCacheKeys","absoluteUrl","cacheKey","setOfCachedUrls","urls","Map","Set","item","relativeUrl","location","addEventListener","event","waitUntil","caches","has","cache","request","requests","fetch","then","response","responseToCache","open","cachedUrls","all","Array","from","values","Request","credentials","skipWaiting","ok","Error","existingRequests","setOfExpectedUrls","shouldRespond","existingRequest","delete","clients","claim","method","console","addDirectoryIndex","directoryIndex","respondWith","get","catch","e"],"mappings":"AAqCA,aAEA,IAAIA,eAAiB,CAAC,CAAC,iBAAD,oCAAD,CAAA,qBAAwD,oCAAqB,CAAtB,qBAA2D,oCAAqB,CAAA,qBAAqC,oCAAqB,CAAA,sBAAqC,oCAAsB,CAAA,uBAAqC,oCAAuB,CAAA,uBAAqC,oCAAuB,CAAA,sBAAqC,oCAAsB,CAAA,cAA/a,oCAAke,CAAA,eAAle,oCAAshB,CAAA,iBAAthB,qCACjBC,UAAY,oBAAsBC,KAAKC,aAAeD,KAAKC,aAAaC,MAAQ,IAGhFC,4BAA8B,CAAC,SAO7BC,kBAAgBC,SAAhBC,EAAAD,GACD,IAAAD,EAAA,IAAAG,IAAAD,GAIDE,MAHA,MAAAJ,EAAOA,SAAAK,OAAP,KALJL,EAAAM,UAAAL,GAQIG,EAAAA,YAGEA,cAAeG,SAAQC,GADzB,OAAKA,EAAiBC,YAWpB,SAAAD,EACAE,QAAOH,QAAII,EAAeC,MACxBC,EAASL,QAEGA,KAAAA,SAAiBM,GALjC,OAAA,IAAAH,SAAAC,EAAA,CAZJC,QAAAL,EAAAK,QAgBQE,OAAQP,EAAiBO,OAM7BC,WAAAA,EAAAA,eAhBAN,QAAAH,QAAAC,IAsBAQ,eAAA,SAAAd,EAAAe,EAAAC,EACKC,GAIJ,IAAAnB,EAAA,IAAAG,IAAAD,GAED,OANKiB,GASLC,EAAAA,SAAAA,MAAoBD,KACpBnB,EAAAqB,SAAArB,EAAAqB,OAAA,IAAA,IACIC,mBAAqBL,GAAG,IAAAM,mBAAAL,IALrBlB,EAAIwB,YAWXJ,kBAAsB,SAAAE,EAASG,GAA/B,GAAA,IAAAH,EAAAI,OARJ,OAAA,EAgBI,IAAAC,EAAA,IAAAxB,IAAAyB,GAAAtB,SACAN,OAAAsB,EAAAO,KAAA,SAAAJ,GARE,OAAOE,EAAKG,MAAML,MAahBM,0BAAsB,SAAA7B,EAHbH,GAMT,IAAAC,EAAOD,IAAAA,IAAAA,GAwBf,OAtBSC,EAFDgC,KAAA,GAKAhC,EAAAqB,OAAUY,EAAKZ,OAAMhB,MAAA,GAEtB4B,MAbU,KAEVC,IAAI,SAASC,GAahB,OAAWX,EAAAA,MAAX,OAVGY,OAAO,SAASD,GAcnBE,OAAAA,EAAJC,MAAA,SAAAC,GACIC,OAAAA,EACF9C,KAAAA,EAAAA,QAGM+C,IAAAA,SAAcN,GACdO,OAAAA,EAAW1B,KAAAA,OALnBiB,KAAA,KAUSU,EAAAA,YAIJN,cAFD,eADKG,gBAIUI,IAAMC,IACrBnD,eAAWoD,IAAIF,SAAfG,GALF,IAAAC,EAAAD,EAAA,GAODf,EAAAe,EAAA,GAdON,EAAc,IAAItC,IAAI6C,EAAapD,KAAKqD,UAgB3CC,EAAAA,eAA4BT,EAASU,cAAOnB,GAAA,GAC/CmB,MAAMC,CAAAA,EACJC,WAAY1D,MAKJ,SAAAgD,gBAAgBW,GACd,OAAAC,EAAIC,OAAAA,KAAU,SAAYd,GAC1B,OAAAe,EAAOC,IAAMF,SAASG,GACpB,OAAAH,EAAAxD,QAEA2D,KAAA,SAAKC,GACH,OAAA,IAAAd,IAAAF,KAKAhD,KAAAsD,iBAAOK,UAAUb,SAAUmB,GAC5BV,EAAAC,UACFC,OAXMS,KAAPnE,WAAAgE,KAAA,SAAAJ,GAYD,OAAAZ,gBAAAY,GAAAI,KAAA,SAAAI,GAjBE,OAAPrD,QAAAsD,IADFC,MAAAC,KAAA1B,gBAAA2B,UAAAjC,IAAA,SAAAQ,GAIM,IAAKqB,EAAWT,IAAIZ,GAAW,CAoBrC,IAAAc,EAAA,IAAAY,QAAA1B,EAAA,CAAA2B,YAAA,gBACOzE,OAAK0E,MAALd,GAAPG,KAAA,SAAAC,GAhBU,IAAKA,EAASW,GAsBzBrB,MAAiB,IAAAsB,MAAY,eAAgB9B,EAAA,oCAChBF,EAAgB2B,QAIrCZ,OAAAnD,cAAkBwD,GAASa,KAAAA,SAAkBZ,GAC3CnD,OACL+D,EAAAA,IAAAA,EAAAZ,eAhBHF,KAAK,WASZ,OAAA/D,KAAA0E,mBA2BI1E,KAAAsD,iBAAA,WAAA,SAAAC,GACA,IAAAuB,EAAA,IAAA5B,IAAAN,gBAAA2B,UAEAhB,EAAAC,UACAC,OAAAS,KAAAnE,WAAAgE,KAAA,SAAAJ,GACA,OAAIvD,EAAM+B,OAAAA,KAAAA,SAA0BoB,GACpCwB,OAAAA,QAAgBnC,IA1BViC,EAAiBvC,IAAI,SAAS0C,GA4BpC,IAAAF,EAAApB,IAAAsB,EAAA5E,KACA,OAAAuD,EAAAsB,OAAAD,UAKCjB,KAAA,WAED,OAAA/D,KAAAkF,QAAAC,aApBJnF,KAAKsD,iBAAiB,QAAS,SAASC,GA+BpC,GAAA,QAAAA,EAAAK,QAAAwB,OAAA,CAKM,IAAAL,EAIE3E,EAAA+B,0BAAYoB,EAAAK,QAAAxD,IAAAD,6BAKdkF,EAAa,cAJZN,EALDnC,gBAAAc,IAAAtD,MAWDA,EAbHkF,kBAAAlF,EAAAmF,GAeDR,EAAAnC,gBAAAc,IAAAtD,IA1BG,EAUA2E,GACFxB,EAAMiC,YACJ/B,OAAOS,KAAKnE,WAAWgE,KAAK,SAASJ,GACnC,OAAOA,EAAMzB,MAAMU,gBAAgB6C,IAAIrF,IAAM2D,KAAK,SAASC,GACzD,GAAIA,EACF,OAAOA,EAET,MAAMY,MAAM,yDAEbc,MAAM,SAASC,GAIhB,OAAO7B,MAAMP,EAAMK","file":"service-worker.js","sourcesContent":["/**\n * Copyright 2016 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\n\n// DO NOT EDIT THIS GENERATED OUTPUT DIRECTLY!\n// This file should be overwritten as part of your build process.\n// If you need to extend the behavior of the generated service worker, the best approach is to write\n// additional code and include it using the importScripts option:\n//   https://github.com/GoogleChrome/sw-precache#importscripts-arraystring\n//\n// Alternatively, it's possible to make changes to the underlying template file and then use that as the\n// new base for generating output, via the templateFilePath option:\n//   https://github.com/GoogleChrome/sw-precache#templatefilepath-string\n//\n// If you go that route, make sure that whenever you update your sw-precache dependency, you reconcile any\n// changes made to this original template file with your modified copy.\n\n// This generated service worker JavaScript will precache your site's resources.\n// The code needs to be saved in a .js file at the top-level of your site, and registered\n// from your pages in order to be used. See\n// https://github.com/googlechrome/sw-precache/blob/master/demo/app/js/service-worker-registration.js\n// for an example of how you can register this script and handle various service worker events.\n\n/* eslint-env worker, serviceworker */\n/* eslint-disable indent, no-unused-vars, no-multiple-empty-lines, max-nested-callbacks, space-before-function-paren, quotes, comma-spacing */\n'use strict';\n\nvar precacheConfig = [[\"/css/index.css\",\"c0281f82182428418cfad38a2ee3a8a6\"],[\"/font/fontello.eot\",\"e5a945dd72ed9579b44f1926decc5d69\"],[\"/font/fontello.svg\",\"6cfcdb1a2abb96602932d4a2601d9c4e\"],[\"/font/fontello.ttf\",\"b732484010111a67bc53d44c88df79a0\"],[\"/font/fontello.woff\",\"c15f138b70af4f6b64e328b22c376c43\"],[\"/font/fontello.woff2\",\"26148360a55ef28c89c538de3c97ed5b\"],[\"/htmlminifier.min.js\",\"e272447f583424c3bfa69670e838cafe\"],[\"/images/bg-main.png\",\"b099df35a7d9bc55229200256263759b\"],[\"/index.html\",\"efe90c7e29b5edc852b7391916e65eaf\"],[\"/js/index.js\",\"e24a2b035b25d77cb37a7119b0462c18\"],[\"/web-worker.js\",\"2d8312078e3f0fd8acaf12303c1eedd0\"]];\nvar cacheName = 'sw-precache-v3--' + (self.registration ? self.registration.scope : '');\n\n\nvar ignoreUrlParametersMatching = [/^utm_/];\n\n\n\nvar addDirectoryIndex = function(originalUrl, index) {\n    var url = new URL(originalUrl);\n    if (url.pathname.slice(-1) === '/') {\n      url.pathname += index;\n    }\n    return url.toString();\n  };\n\nvar cleanResponse = function(originalResponse) {\n    // If this is not a redirected response, then we don't have to do anything.\n    if (!originalResponse.redirected) {\n      return Promise.resolve(originalResponse);\n    }\n\n    // Firefox 50 and below doesn't support the Response.body stream, so we may\n    // need to read the entire body to memory as a Blob.\n    var bodyPromise = 'body' in originalResponse ?\n      Promise.resolve(originalResponse.body) :\n      originalResponse.blob();\n\n    return bodyPromise.then(function(body) {\n      // new Response() is happy when passed either a stream or a Blob.\n      return new Response(body, {\n        headers: originalResponse.headers,\n        status: originalResponse.status,\n        statusText: originalResponse.statusText\n      });\n    });\n  };\n\nvar createCacheKey = function(originalUrl, paramName, paramValue,\n                           dontCacheBustUrlsMatching) {\n    // Create a new URL object to avoid modifying originalUrl.\n    var url = new URL(originalUrl);\n\n    // If dontCacheBustUrlsMatching is not set, or if we don't have a match,\n    // then add in the extra cache-busting URL parameter.\n    if (!dontCacheBustUrlsMatching ||\n        !(url.pathname.match(dontCacheBustUrlsMatching))) {\n      url.search += (url.search ? '&' : '') +\n        encodeURIComponent(paramName) + '=' + encodeURIComponent(paramValue);\n    }\n\n    return url.toString();\n  };\n\nvar isPathWhitelisted = function(whitelist, absoluteUrlString) {\n    // If the whitelist is empty, then consider all URLs to be whitelisted.\n    if (whitelist.length === 0) {\n      return true;\n    }\n\n    // Otherwise compare each path regex to the path of the URL passed in.\n    var path = (new URL(absoluteUrlString)).pathname;\n    return whitelist.some(function(whitelistedPathRegex) {\n      return path.match(whitelistedPathRegex);\n    });\n  };\n\nvar stripIgnoredUrlParameters = function(originalUrl,\n    ignoreUrlParametersMatching) {\n    var url = new URL(originalUrl);\n    // Remove the hash; see https://github.com/GoogleChrome/sw-precache/issues/290\n    url.hash = '';\n\n    url.search = url.search.slice(1) // Exclude initial '?'\n      .split('&') // Split into an array of 'key=value' strings\n      .map(function(kv) {\n        return kv.split('='); // Split each 'key=value' string into a [key, value] array\n      })\n      .filter(function(kv) {\n        return ignoreUrlParametersMatching.every(function(ignoredRegex) {\n          return !ignoredRegex.test(kv[0]); // Return true iff the key doesn't match any of the regexes.\n        });\n      })\n      .map(function(kv) {\n        return kv.join('='); // Join each [key, value] array into a 'key=value' string\n      })\n      .join('&'); // Join the array of 'key=value' strings into a string with '&' in between each\n\n    return url.toString();\n  };\n\n\nvar hashParamName = '_sw-precache';\nvar urlsToCacheKeys = new Map(\n  precacheConfig.map(function(item) {\n    var relativeUrl = item[0];\n    var hash = item[1];\n    var absoluteUrl = new URL(relativeUrl, self.location);\n    var cacheKey = createCacheKey(absoluteUrl, hashParamName, hash, false);\n    return [absoluteUrl.toString(), cacheKey];\n  })\n);\n\nfunction setOfCachedUrls(cache) {\n  return cache.keys().then(function(requests) {\n    return requests.map(function(request) {\n      return request.url;\n    });\n  }).then(function(urls) {\n    return new Set(urls);\n  });\n}\n\nself.addEventListener('install', function(event) {\n  event.waitUntil(\n    caches.open(cacheName).then(function(cache) {\n      return setOfCachedUrls(cache).then(function(cachedUrls) {\n        return Promise.all(\n          Array.from(urlsToCacheKeys.values()).map(function(cacheKey) {\n            // If we don't have a key matching url in the cache already, add it.\n            if (!cachedUrls.has(cacheKey)) {\n              var request = new Request(cacheKey, {credentials: 'same-origin'});\n              return fetch(request).then(function(response) {\n                // Bail out of installation unless we get back a 200 OK for\n                // every request.\n                if (!response.ok) {\n                  throw new Error('Request for ' + cacheKey + ' returned a ' +\n                    'response with status ' + response.status);\n                }\n\n                return cleanResponse(response).then(function(responseToCache) {\n                  return cache.put(cacheKey, responseToCache);\n                });\n              });\n            }\n          })\n        );\n      });\n    }).then(function() {\n      \n      // Force the SW to transition from installing -> active state\n      return self.skipWaiting();\n      \n    })\n  );\n});\n\nself.addEventListener('activate', function(event) {\n  var setOfExpectedUrls = new Set(urlsToCacheKeys.values());\n\n  event.waitUntil(\n    caches.open(cacheName).then(function(cache) {\n      return cache.keys().then(function(existingRequests) {\n        return Promise.all(\n          existingRequests.map(function(existingRequest) {\n            if (!setOfExpectedUrls.has(existingRequest.url)) {\n              return cache.delete(existingRequest);\n            }\n          })\n        );\n      });\n    }).then(function() {\n      \n      return self.clients.claim();\n      \n    })\n  );\n});\n\n\nself.addEventListener('fetch', function(event) {\n  if (event.request.method === 'GET') {\n    // Should we call event.respondWith() inside this fetch event handler?\n    // This needs to be determined synchronously, which will give other fetch\n    // handlers a chance to handle the request if need be.\n    var shouldRespond;\n\n    // First, remove all the ignored parameters and hash fragment, and see if we\n    // have that URL in our cache. If so, great! shouldRespond will be true.\n    var url = stripIgnoredUrlParameters(event.request.url, ignoreUrlParametersMatching);\n    shouldRespond = urlsToCacheKeys.has(url);\n\n    // If shouldRespond is false, check again, this time with 'index.html'\n    // (or whatever the directoryIndex option is set to) at the end.\n    var directoryIndex = 'index.html';\n    if (!shouldRespond && directoryIndex) {\n      url = addDirectoryIndex(url, directoryIndex);\n      shouldRespond = urlsToCacheKeys.has(url);\n    }\n\n    // If shouldRespond is still false, check to see if this is a navigation\n    // request, and if so, whether the URL matches navigateFallbackWhitelist.\n    var navigateFallback = '';\n    if (!shouldRespond &&\n        navigateFallback &&\n        (event.request.mode === 'navigate') &&\n        isPathWhitelisted([], event.request.url)) {\n      url = new URL(navigateFallback, self.location).toString();\n      shouldRespond = urlsToCacheKeys.has(url);\n    }\n\n    // If shouldRespond was set to true at any point, then call\n    // event.respondWith(), using the appropriate cache key.\n    if (shouldRespond) {\n      event.respondWith(\n        caches.open(cacheName).then(function(cache) {\n          return cache.match(urlsToCacheKeys.get(url)).then(function(response) {\n            if (response) {\n              return response;\n            }\n            throw Error('The cached response that was expected is missing.');\n          });\n        }).catch(function(e) {\n          // Fall back to just fetch()ing the request if some unexpected error\n          // prevented the cached response from being valid.\n          console.warn('Couldn\\'t serve response for \"%s\" from cache: %O', event.request.url, e);\n          return fetch(event.request);\n        })\n      );\n    }\n  }\n});\n\n\n\n\n\n\n\n"]}